<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>codigo</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="Codigo_files/libs/clipboard/clipboard.min.js"></script>
<script src="Codigo_files/libs/quarto-html/quarto.js"></script>
<script src="Codigo_files/libs/quarto-html/popper.min.js"></script>
<script src="Codigo_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Codigo_files/libs/quarto-html/anchor.min.js"></script>
<link href="Codigo_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Codigo_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Codigo_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Codigo_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Codigo_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<p>Ahora vamos a llevar a cabo una prueba práctica del algoritmo de teleportación. Para ello hemos llevado a cabo, a través de un cuaderno de jupyter, un experimento a través del cuál se demuestra como se realiza el paso de la información desde el qubit de Alice al de Bob, desde un punto de vista práctico.</p>
<p>Dicho código puede ejecutarse desde IBM QuantumLab.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ibm_quantum_widgets <span class="im">import</span> CircuitComposer</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit <span class="im">import</span> QuantumRegister, ClassicalRegister, QuantumCircuit</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy <span class="im">import</span> pi</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit <span class="im">import</span> QuantumCircuit, execute, Aer, IBMQ</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.compiler <span class="im">import</span> transpile, assemble</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.tools.jupyter <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.visualization <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.extensions <span class="im">import</span> Initialize</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.quantum_info <span class="im">import</span> random_statevector</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.ignis.verification <span class="im">import</span> marginal_counts</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Comenzamos almacenando en variables los diferentes métodos de ejecución del circuito para su posterior uso:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>backend_unitary <span class="op">=</span> Aer.get_backend(<span class="st">'unitary_simulator'</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>backend_qasm <span class="op">=</span> Aer.get_backend(<span class="st">'qasm_simulator'</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>backend_stvec <span class="op">=</span> Aer.get_backend(<span class="st">'statevector_simulator'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>backend_sim <span class="op">=</span> Aer.get_backend(<span class="st">'aer_simulator'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Comenzamos construyendo el circuito donde los qbits <span class="math inline">\(q_0\)</span> y <span class="math inline">\(q_1\)</span> se corresponden con Alice, mientras que el qbit <span class="math inline">\(q_2\)</span> será para Bob.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>qreg_q <span class="op">=</span> QuantumRegister(<span class="dv">3</span>, <span class="st">'q'</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>creg_c <span class="op">=</span> ClassicalRegister(<span class="dv">2</span>, <span class="st">'c'</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>circuit <span class="op">=</span> QuantumCircuit(qreg_q, creg_c)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A continuación, vamos a inicializar el qubit <span class="math inline">\(q_0\)</span>. Para ello le asignaremos un valor aleatorio como vector de estados. Nuestro objetivo será ver que dicho valor se transporta correctamente al qubit <span class="math inline">\(q_2\)</span>.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Sacamos un vector aleatorio que inicialice el qbit q0</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>init_value <span class="op">=</span> random_statevector(<span class="dv">2</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">#Creamos la puerta que inicializará el qbit</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>init_gate <span class="op">=</span> Initialize(init_value)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>init_gate.label <span class="op">=</span> <span class="st">"init_value"</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Añadimos el la puerta que inicializa el qbit q0 a nuestro circuito</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>circuit.append(init_gate, [<span class="dv">0</span>])</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>circuit.barrier()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>&lt;qiskit.circuit.instructionset.InstructionSet at 0x1c73b77c8b0&gt;</code></pre>
</div>
</div>
<p>El valor con el cuál inicializamos <span class="math inline">\(q_0\)</span> será el siguiente</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>display(array_to_latex(init_value, prefix<span class="op">=</span><span class="st">"|</span><span class="ch">\\</span><span class="st">psi</span><span class="ch">\\</span><span class="st">rangle ="</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>&lt;IPython.core.display.Latex object&gt;</code></pre>
</div>
</div>
<p>Para el segundo y tercer qbit será necesario aplicar en estado de Bell. Para ello introduciremos una puerta de Hadamard y otra CNOT en este orden.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>circuit.h(qreg_q[<span class="dv">1</span>])</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>circuit.cx(qreg_q[<span class="dv">1</span>], qreg_q[<span class="dv">2</span>])</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>circuit.draw()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌─────────────────────────────────────────────────┐ ░           
q_0: ┤ init_value(0.41646+0.76195j,-0.021579-0.49551j) ├─░───────────
     └─────────────────────────────────────────────────┘ ░ ┌───┐     
q_1: ────────────────────────────────────────────────────░─┤ H ├──■──
                                                         ░ └───┘┌─┴─┐
q_2: ────────────────────────────────────────────────────░──────┤ X ├
                                                         ░      └───┘
c_0: ════════════════════════════════════════════════════════════════
                                                                     
c_1: ════════════════════════════════════════════════════════════════
                                                                     </pre>
</div>
</div>
<p>A continuación, para poder llevar a cabo el algoritmo de teleportación, aplicamos en los qbits pertenecientes a Alice una transformación de la siguiente manera: una puerta CNOT para <span class="math inline">\(q_0\)</span> y <span class="math inline">\(q_1\)</span>, y una de Hadamard para el qbit <span class="math inline">\(q_0\)</span>.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>circuit.barrier(qreg_q[<span class="dv">0</span>], qreg_q[<span class="dv">1</span>], qreg_q[<span class="dv">2</span>])</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>circuit.cx(qreg_q[<span class="dv">0</span>], qreg_q[<span class="dv">1</span>])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>circuit.h(qreg_q[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>&lt;qiskit.circuit.instructionset.InstructionSet at 0x1c73b77d4e0&gt;</code></pre>
</div>
</div>
<p>El circuito quedará de la siguiente forma:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>circuit.draw()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌─────────────────────────────────────────────────┐ ░            ░      »
q_0: ┤ init_value(0.41646+0.76195j,-0.021579-0.49551j) ├─░────────────░───■──»
     └─────────────────────────────────────────────────┘ ░ ┌───┐      ░ ┌─┴─┐»
q_1: ────────────────────────────────────────────────────░─┤ H ├──■───░─┤ X ├»
                                                         ░ └───┘┌─┴─┐ ░ └───┘»
q_2: ────────────────────────────────────────────────────░──────┤ X ├─░──────»
                                                         ░      └───┘ ░      »
c_0: ════════════════════════════════════════════════════════════════════════»
                                                                             »
c_1: ════════════════════════════════════════════════════════════════════════»
                                                                             »
«     ┌───┐
«q_0: ┤ H ├
«     └───┘
«q_1: ─────
«          
«q_2: ─────
«          
«c_0: ═════
«          
«c_1: ═════
«          </pre>
</div>
</div>
<p>Veamos la matriz que interviene en nuestro circuito.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>unitary<span class="op">=</span> execute(circuit,backend_unitary,shots<span class="op">=</span><span class="dv">1024</span>).result().get_unitary()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>array_to_latex(unitary)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>&lt;IPython.core.display.Latex object&gt;</code></pre>
</div>
</div>
<p>Y este será el vector de estados final, tras aplicarse dicha parte del algoritmo:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>final_state<span class="op">=</span> execute(circuit,backend_stvec,shots<span class="op">=</span><span class="dv">1024</span>).result().get_statevector()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>array_to_latex(final_state)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>&lt;IPython.core.display.Latex object&gt;</code></pre>
</div>
</div>
<p>Introducimos dos medidores para <span class="math inline">\(q_0\)</span> y <span class="math inline">\(q_1\)</span> y una barrera para separar el circuito de dichos medidores.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>circuit.barrier(qreg_q[<span class="dv">0</span>], qreg_q[<span class="dv">1</span>], qreg_q[<span class="dv">2</span>])</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>circuit.measure(qreg_q[<span class="dv">0</span>], creg_c[<span class="dv">0</span>])</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>circuit.measure(qreg_q[<span class="dv">1</span>], creg_c[<span class="dv">1</span>])</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>circuit.draw()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌─────────────────────────────────────────────────┐ ░            ░      »
q_0: ┤ init_value(0.41646+0.76195j,-0.021579-0.49551j) ├─░────────────░───■──»
     └─────────────────────────────────────────────────┘ ░ ┌───┐      ░ ┌─┴─┐»
q_1: ────────────────────────────────────────────────────░─┤ H ├──■───░─┤ X ├»
                                                         ░ └───┘┌─┴─┐ ░ └───┘»
q_2: ────────────────────────────────────────────────────░──────┤ X ├─░──────»
                                                         ░      └───┘ ░      »
c_0: ════════════════════════════════════════════════════════════════════════»
                                                                             »
c_1: ════════════════════════════════════════════════════════════════════════»
                                                                             »
«     ┌───┐ ░ ┌─┐   
«q_0: ┤ H ├─░─┤M├───
«     └───┘ ░ └╥┘┌─┐
«q_1: ──────░──╫─┤M├
«           ░  ║ └╥┘
«q_2: ──────░──╫──╫─
«           ░  ║  ║ 
«c_0: ═════════╩══╬═
«                 ║ 
«c_1: ════════════╩═
«                   </pre>
</div>
</div>
<p>Por último, para descodificar la información transmitida al qbit <span class="math inline">\(q_2\)</span>, aplicaremos dos condicionales a las puertas NOT y Z. De modo que si tienen valor 1 se aplicarán al estado. Así, se seguirá el esquema siguiente:</p>
<p><span class="math display">\[
00 \longrightarrow \text{no se aplica ninguna puerta cuántica}
\]</span> <span class="math display">\[
01 \longrightarrow \text{se aplica la puerta cuántica  } X = \sigma_3
\]</span> <span class="math display">\[
10 \longrightarrow \text{se aplica la puerta cuántica  } Z = \sigma_1
\]</span> <span class="math display">\[
11 \longrightarrow \text{se aplican las puertas cuánticas  } XZ = \sigma_3 \sigma_1
\]</span></p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>circuit.barrier(qreg_q[<span class="dv">0</span>], qreg_q[<span class="dv">1</span>],qreg_q[<span class="dv">2</span>])</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>circuit.x(<span class="dv">2</span>).c_if(creg_c[<span class="dv">1</span>], <span class="dv">1</span>) </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>circuit.z(<span class="dv">2</span>).c_if(creg_c[<span class="dv">0</span>], <span class="dv">1</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>circuit.draw()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌─────────────────────────────────────────────────┐ ░            ░      »
q_0: ┤ init_value(0.41646+0.76195j,-0.021579-0.49551j) ├─░────────────░───■──»
     └─────────────────────────────────────────────────┘ ░ ┌───┐      ░ ┌─┴─┐»
q_1: ────────────────────────────────────────────────────░─┤ H ├──■───░─┤ X ├»
                                                         ░ └───┘┌─┴─┐ ░ └───┘»
q_2: ────────────────────────────────────────────────────░──────┤ X ├─░──────»
                                                         ░      └───┘ ░      »
c_0: ════════════════════════════════════════════════════════════════════════»
                                                                             »
c_1: ════════════════════════════════════════════════════════════════════════»
                                                                             »
«     ┌───┐ ░ ┌─┐    ░           
«q_0: ┤ H ├─░─┤M├────░───────────
«     └───┘ ░ └╥┘┌─┐ ░           
«q_1: ──────░──╫─┤M├─░───────────
«           ░  ║ └╥┘ ░ ┌───┐┌───┐
«q_2: ──────░──╫──╫──░─┤ X ├┤ Z ├
«           ░  ║  ║  ░ └─╥─┘└─╥─┘
«c_0: ═════════╩══╬══════╬════■══
«                 ║      ║       
«c_1: ════════════╩══════■═══════
«                                </pre>
</div>
</div>
<p>Vamos a comprobar si se ha llevado correctamente el experimento. En un ordenador cuántico no es posible mostrar el vector de estados, así que para comprobar si todo ha ido bien utilizaremos otra forma. La puerta <em>init</em> que hemos aplicado al qbit <span class="math inline">\(q_0\)</span> al principio del algoritmo, nos ha permitido pasar del estado inicial de nuestro circuito <span class="math inline">\(|0\rangle\)</span>, a un estado aleatorio a partir del cual ibamos a inicializar el algoritmo. De este modo, aplicaremos la inversa de esta puerta <em>init</em> al qbit <span class="math inline">\(q_2\)</span>. Si nos devuelve el estado <span class="math inline">\(|0\rangle\)</span> con un <span class="math inline">\(100%\)</span> de probabilidad, podremos asegurar que toda la información del qubit <span class="math inline">\(q_0\)</span> se ha transportado correctamente a <span class="math inline">\(q_2\)</span>.</p>
<p>Procederemos del siguiente modo: tras meter una barrera para separar esta nueva parte, añadiremos la puerta inversa a <span class="math inline">\(q_2\)</span> y un medidor.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>circuit.barrier(qreg_q[<span class="dv">0</span>], qreg_q[<span class="dv">1</span>],qreg_q[<span class="dv">2</span>]) <span class="co">#barrera de separación</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Añadimos la puerta inversa</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>inverse_init <span class="op">=</span> init_gate.gates_to_uncompute()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>circuit.append(inverse_init, [<span class="dv">2</span>])</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">#Creamos un nuevo registro clásico donde se apoyará el nuevo medidor</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>c_2 <span class="op">=</span> ClassicalRegister(<span class="dv">1</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>circuit.add_register(c_2)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co">#Añadimos el medidor para el qubit q2</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>circuit.measure(<span class="dv">2</span>,<span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>&lt;qiskit.circuit.instructionset.InstructionSet at 0x1c73b77de40&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>circuit.draw()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌─────────────────────────────────────────────────┐ ░            ░      »
q_0: ┤ init_value(0.41646+0.76195j,-0.021579-0.49551j) ├─░────────────░───■──»
     └─────────────────────────────────────────────────┘ ░ ┌───┐      ░ ┌─┴─┐»
q_1: ────────────────────────────────────────────────────░─┤ H ├──■───░─┤ X ├»
                                                         ░ └───┘┌─┴─┐ ░ └───┘»
q_2: ────────────────────────────────────────────────────░──────┤ X ├─░──────»
                                                         ░      └───┘ ░      »
c_0: ════════════════════════════════════════════════════════════════════════»
                                                                             »
c_1: ════════════════════════════════════════════════════════════════════════»
                                                                             »
 c0: ════════════════════════════════════════════════════════════════════════»
                                                                             »
«     ┌───┐ ░ ┌─┐    ░            ░                    
«q_0: ┤ H ├─░─┤M├────░────────────░────────────────────
«     └───┘ ░ └╥┘┌─┐ ░            ░                    
«q_1: ──────░──╫─┤M├─░────────────░────────────────────
«           ░  ║ └╥┘ ░ ┌───┐┌───┐ ░ ┌──────────────┐┌─┐
«q_2: ──────░──╫──╫──░─┤ X ├┤ Z ├─░─┤ disentangler ├┤M├
«           ░  ║  ║  ░ └─╥─┘└─╥─┘ ░ └──────────────┘└╥┘
«c_0: ═════════╩══╬══════╬════■══════════════════════╬═
«                 ║      ║                           ║ 
«c_1: ════════════╩══════■═══════════════════════════╬═
«                                                    ║ 
« c0: ═══════════════════════════════════════════════╩═
«                                                      </pre>
</div>
</div>
<p>Llevamos a cabo la representación de nuestras mediciones a través de un histograma.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>t_qc <span class="op">=</span> transpile(circuit, sim)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>t_qc.save_statevector()</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>counts <span class="op">=</span> sim.run(t_qc).result().get_counts()</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>qubit_counts <span class="op">=</span> [marginal_counts(counts, [qubit]) <span class="cf">for</span> qubit <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>)]</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>plot_histogram(qubit_counts)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\Lenovo\AppData\Local\Temp\ipykernel_704504\2833224662.py:2: DeprecationWarning: The qiskit.ignis package is deprecated and has been supersceded by the qiskit-experiments project. Refer to the migration guide: https://github.com/Qiskit/qiskit-ignis#migration-guide on how to migrate to the new project.
  from qiskit.ignis.verification import marginal_counts</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="15">
<p><img src="Codigo_files/figure-html/cell-16-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Echando un ojo a nuestro histograma, vemos que todos los disparos se miden finalmente con estado <span class="math inline">\(|0\rangle\)</span> para el caso del qubit <span class="math inline">\(q_2\)</span> representado con la barra morada. Con esto podemos concluir que con un <span class="math inline">\(100\%\)</span> de probabilidad nuestro experimento habrá transmitido toda la información de <span class="math inline">\(q_0\)</span> a <span class="math inline">\(q_2\)</span>.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    circuit.data.pop(<span class="dv">13</span>) <span class="co">#borramos el vector de estados almacenado en nuestro circuito</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>circuit.draw()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌─────────────────────────────────────────────────┐ ░            ░      »
q_0: ┤ init_value(0.41646+0.76195j,-0.021579-0.49551j) ├─░────────────░───■──»
     └─────────────────────────────────────────────────┘ ░ ┌───┐      ░ ┌─┴─┐»
q_1: ────────────────────────────────────────────────────░─┤ H ├──■───░─┤ X ├»
                                                         ░ └───┘┌─┴─┐ ░ └───┘»
q_2: ────────────────────────────────────────────────────░──────┤ X ├─░──────»
                                                         ░      └───┘ ░      »
c_0: ════════════════════════════════════════════════════════════════════════»
                                                                             »
c_1: ════════════════════════════════════════════════════════════════════════»
                                                                             »
 c0: ════════════════════════════════════════════════════════════════════════»
                                                                             »
«     ┌───┐ ░ ┌─┐    ░           
«q_0: ┤ H ├─░─┤M├────░───────────
«     └───┘ ░ └╥┘┌─┐ ░           
«q_1: ──────░──╫─┤M├─░───────────
«           ░  ║ └╥┘ ░ ┌───┐┌───┐
«q_2: ──────░──╫──╫──░─┤ X ├┤ Z ├
«           ░  ║  ║  ░ └─╥─┘└─╥─┘
«c_0: ═════════╩══╬══════╬════■══
«                 ║      ║       
«c_1: ════════════╩══════■═══════
«                                
« c0: ═══════════════════════════
«                                </pre>
</div>
</div>
<p>Ahora veamos graficamente si el vector de estados tras el algoritmo de <span class="math inline">\(q_2\)</span> correspondiente a la información que descodica Bob coincide con la inicialmente dispone Alice en <span class="math inline">\(q_0\)</span>.</p>
<p>El vector inicial correspondiente a la información que quería transmitir Alice era el siguiente:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>plot_bloch_multivector(init_value)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<p><img src="Codigo_files/figure-html/cell-19-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Comparándolo con los estados finales de los tres qbits, vemos que se ha transmitido correctamente al qbit <span class="math inline">\(q_2\)</span>. Pues ambas representaciones coinciden.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>circuit.save_statevector()</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>out_vector <span class="op">=</span> backend_sim.run(circuit).result().get_statevector()</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>plot_bloch_multivector(out_vector)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<p><img src="Codigo_files/figure-html/cell-20-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Veamos ahora desde un punto de vista gráfico, el valor que adopta el vector de estados para los tres qbits:</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>job <span class="op">=</span> execute(circuit, backend_qasm, shots<span class="op">=</span><span class="dv">1024</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>plot_histogram(job.result().get_counts(), title<span class="op">=</span><span class="st">"Vector de estado"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<p><img src="Codigo_files/figure-html/cell-21-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Tal y como podemos observar, tras lanzar 1024 disparos a nuestro experimento, serán 4 los posibles estados finales, a pesar de tener 3 <span class="math inline">\(qbits\)</span>. Esto se debe a lo visto anteriormente, pues el qbit <span class="math inline">\(q_2\)</span> adoptará siempre el mismo estado final. Y por lo tanto, los estados finales de los qbits restantes oscilarán entre estos cuatro valores con la misma probabilidad, aproximadamente.</p>
<p>Y de esta forma, hemos hecho una muestra práctica de cómo funciona el algoritmo de teleportación.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>